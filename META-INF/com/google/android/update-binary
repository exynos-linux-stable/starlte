#!/sbin/sh
#

ZIPFILE=$3
OUTFD=$2

kernel=4.9.130
apgk=0.99.22
build=1

# Detect real $OUTFD
readlink /proc/$$/fd/$OUTFD 2>/dev/null | grep /tmp >/dev/null
if [ $? -eq 0 ]; then
  OUTFD=0
  for FD in `ls /proc/$$/fd` ; do
    readlink /proc/$$/fd/$FD 2>/dev/null | grep pipe >/dev/null
    if [ $? -eq 0 ]; then
      ps | grep " 3 $FD " | grep -v grep >/dev/null
      if [ $? -eq 0 ]; then
	OUTFD=$FD
	break
      fi
    fi
  done
fi

ui_print() {
  echo -n -e "ui_print $1\n" >> /proc/self/fd/$OUTFD
  echo -n -e "ui_print\n" >> /proc/self/fd/$OUTFD
}

resolve_link() {
  if [ -z "$1" ] || [ ! -e $1 ] ; then return 1 ; fi
  local VAR=$1
  while [ -L $VAR ]; do
    VAR=$(readlink $VAR)
  done
  echo $VAR
}

unzip_file() {
  unzip -l "$ZIPFILE" | grep "$1" >/dev/null || return 1
  unzip -p "$ZIPFILE" $1 > $2
  return $?
}


ui_print " "
ui_print "======================================="
ui_print "         APGK $kernel-$apgk-$build"
ui_print "         a pretty good kernel"
ui_print "=======================================" 
ui_print " "

bl=$( getprop ro.boot.bootloader )
fw=${bl:9:4}
device=${bl:0:5}
model=${device:0:4}
suffix=${device:4}

# BusyBox shell sucks.
#
#if [[ $device != G96[05][FN] ]]; then
if ! ( [ $model = G960 ] || [ $model = G965 ] &&
       [ $suffix = F ]   || [ $suffix = N ] ); then
  ui_print " - Unsupported device detected. Installation aborted."
  ui_print " "
  exit 1
fi

ui_print " - Detected a $device device on $fw firmware."

[ $suffix = N ] &&
  ui_print " - NOTE: '$suffix' device support is experimental."

BOOT=$(resolve_link $(find /dev/block/platform -type l -iname boot)) ||
  BOOT=$(resolve_link $(find /dev/block/platform -type l -iname kernel))

if [ -z "$BOOT" ]; then
  ui_print " - No boot partition found. Installation aborted."
  ui_print " "
  exit 1
fi

# Read kernel choice from archive name, if applicable.
#
ZIPNAME=${ZIPFILE##*/}
[ $ZIPNAME != ${ZIPNAME/_underclock//} ] && UNDERCLOCK=true
[ $ZIPNAME != ${ZIPNAME/_overclock//} ] && OVERCLOCK=true

# Otherwise, check for dotfiles to determine kernel choice.
#
[ -f /external_sd/.underclock ] && UNDERCLOCK=true
[ -f /external_sd/.overclock ] && OVERCLOCK=true

# Now get to work.
#
for i in boot-G965F.img boot-G965F-oc.img.bsdiff boot-G965F-uc.img.bsdiff \
boot-G960F.img.bsdiff boot-G960F-oc.img.bsdiff boot-G960F-uc.img.bsdiff \
bspatch; do
  unzip_file $i /tmp/$i
done

bspatch=/tmp/bspatch
chmod 755 $bspatch

image=standard
variant=""
src_img=/tmp/boot-G965F.img
img_960=/tmp/boot-G960F.img

if [ "$OVERCLOCK" = true ]; then
  image=overclock
  variant=-oc
elif [ "$UNDERCLOCK" = true ]; then
  image=underclock
  variant=-uc
fi

dst_img=/tmp/boot-${model}F$variant.img

if [ -f $dst_img.bsdiff ]; then
  ui_print " - Constructing $image kernel for $device..."

  if [ $model = G960 ] && [ -n "$variant" ]; then
    # First produce the standard G960F image, because the oc and uc deltas
    # are based on that.
    #
    $bspatch $src_img $img_960 $img_960.bsdiff
    src_img=$img_960
  fi

  [ -f $dst_img ] || $bspatch $src_img $dst_img $dst_img.bsdiff
fi

ui_print " - Flashing $image boot image onto $device..."
[ -n "$debug" ] && ui_print " - dd if=$dst_img of=$BOOT"

/sbin/dd if=$dst_img of=$BOOT 

ui_print " - Installation completed."

# Read desire to install Magisk from archive name, if applicable.
#
[ $ZIPNAME != ${ZIPNAME/_magisk//} ] && MAGISK=true

# Check for dotfile existence and install Magisk if present.
#
int=/sdcard/Download	# The standard download location on internal SD card.
ext=/external_sd	# The external SD card, if present.

# If .magisk exists at none of these locations and the APGK zip file doesn't
# contain _magisk in the name, we are finished.
#
if [ ! -f $int/.magisk ] && [ ! -f $ext/.magisk ] && [ -z "$MAGISK" ]; then
  ui_print " - You may now root the device at your discretion."
  ui_print " "

  exit 0
fi

# Find the most recent build of Magisk from the various locations.
#
# The order of precedence is:
#
# 1. Files with an explicit version in their name, e.g kantjer and ianmacd
#    builds.
# 2. Unversioned files that indicate a release build with their name, e.g.
#    official Canary channel release builds.
# 3. Unversioned files that indicate a debug build with their name, e.g.
#    official Canary channel debug builds.
# 4. Unversioned files matching the pattern [Mm]agisk.zip, e.g. files
#    extracted from ROMs, etc.
#
# Lexical sort order is used for category 1. The timestamp of the file is used
# for all others. If no files are found, we cannot proceed.
#
magisk=$( { ls -r $int/Magisk-v* $ext/Magisk/Magisk-v* 2>/dev/null;
	    ls -t $int/magisk-release.zip
		  $ext/Magisk/magisk-release.zip 2>/dev/null;
	    ls -t $int/magisk-debug.zip
		  $ext/Magisk/magisk-debug.zip 2>/dev/null;
	    ls -t $int/[Mm]agisk.zip
	    $ext/Magisk/[Mm]agisk.zip 2>/dev/null; } | head -n 1 )
if [ ! -f "$magisk" ]; then
  ui_print " - No Magisk zip file found."
  ui_print " "

  exit 1
fi

ui_print " - Installing ${magisk##*/}..."
ui_print " "

tmp=/tmp/magisk
mkdir $tmp
unzip -d $tmp $magisk META-INF/com/google/android/\* 
exec /sbin/sh $tmp/META-INF/com/google/android/update-binary dummy $OUTFD $magisk
